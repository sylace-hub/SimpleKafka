import java.io.PrintWriter
import java.nio.file.{Files, Paths}
import java.util.Properties

import org.apache.kafka.clients.consumer.{ConsumerRecord, KafkaConsumer}
import org.apache.kafka.clients.producer.{KafkaProducer, ProducerRecord}
import scalaj.http.{Http, HttpResponse}

import scala.collection.JavaConverters._
import com.typesafe.config.ConfigFactory

import java.io.File
import File.separatorChar

object Main {

  def main(args: Array[String]): Unit = {

    // Producer
    val producerProperties = new Properties()

    // Config Kafka
    producerProperties.put("bootstrap.servers", "http://127.0.0.1:9092")
    producerProperties.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer")
    producerProperties.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer")

    val producer = new KafkaProducer[String, String](producerProperties)

    // Consumer
    val consumerProperties = new Properties()

    consumerProperties.put("bootstrap.servers", "http://127.0.0.1:9092")
    consumerProperties.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer")
    consumerProperties.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer")
    consumerProperties.put("group.id", "foobar-group")

    val consumer = new KafkaConsumer[String, String](consumerProperties)

    // Subscribe on topics
    // Topics
    val topics = Array("USA", "FRA", "UK")

    consumer.subscribe(topics.toList.asJava)

    // Requests by topic
    val requests: scala.collection.mutable.Map[String, HttpResponse[String]] = scala.collection.mutable.Map()

    val path = ConfigFactory.load().getString("local-env.app.outdir")
    if (!(Files.exists(Paths.get(path)))) {
      Files.createDirectory(Paths.get(path))
    }

    for (topic <- topics) {
      requests += (topic -> Http("https://newsapi.org/v2/everything").params(Map(
        "q" -> topic,
        "from" -> "2019-04-15",
        "to" -> "2019-04-17",
        "sortBy" -> "relevancy",
        "apiKey" -> "4e86ff31690e4f9b9b65c06ae033cc28"
      )).asString)

      if (!(Files.exists(Paths.get(path + "" + topic)))) {
        Files.createDirectory(Paths.get(path + "" + topic))
      }
    }

    while (true) {
      // Writing
      for ((k, v) <- requests) {
        val record = new ProducerRecord[String, String](k, "key", v.body)
        producer.send(record)
      }

      // Reading
      val records = consumer.poll(500)

      for (record: ConsumerRecord[String, String] <- records.asScala) {
        // Logs
        println()
        println("*** Consumer reading ***")
        println("----")
        println("Topic : " + record.topic())
        println("Value : " + record.value())

        val writer = new PrintWriter(path + "" + record.topic() + separatorChar + record.timestamp() + ".txt")
        writer.write(record.value())
        writer.close()
      }

      Thread.sleep(8000)
    }

    producer.close()
    consumer.close()
  }
}